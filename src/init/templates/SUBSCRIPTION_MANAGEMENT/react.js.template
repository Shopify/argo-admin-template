import React, {useState, useEffect} from 'react';
import {
  ExtensionPoint,
  TextField,
  Text,
  Stack,
  Checkbox,
} from '@shopify/argo-admin';
import {
  render,
  useData,
  useContainer,
  useSessionToken,
} from '@shopify/argo-admin/react';

// 'Add' mode should allow a user to add the current product to an existing selling plan
function Add() {
  // Information about the product and/or plan your extension is editing.
  // Your extension receives different data in each mode.
  const data = useData();

  // The UI your extension renders inside
  const {close, done, setPrimaryAction, setSecondaryAction} = useContainer();

  // Session token contains information about the current user. Use it to authenticate calls
  // from your extension to your app server.
  const {getSessionToken} = useSessionToken();

  const [selectedPlans, setSelectedPlans] = useState([]);
  const mockPlans = [
    {name: 'Subscription Plan A', id: 'a'},
    {name: 'Subscription Plan B', id: 'b'},
    {name: 'Subscription Plan C', id: 'c'},
  ];

  // Configure the extension container UI
  useEffect(() => {
    setPrimaryAction({
      content: 'Add to plan',
      onAction: async () => {
        // Get a fresh session token before every call to your app server.
        const token = await getSessionToken();

        // Here, send the form data to your app server to add the product to an existing plan.

        // Upon completion, call done() to trigger a reload of the resource page, and close() to
        // terminate the extension.
        done();
        close();
      },
    });

    setSecondaryAction({
      content: 'Cancel',
      onAction: () => close(),
    });
  }, [getSessionToken]);

  return (
    <>
      <Text>
        Add {`{Product id ${data.productId}}`} to an existing plan or existing
        plans
      </Text>

      <Stack>
        {mockPlans.map((plan) => (
          <Checkbox
            key={plan.id}
            label={plan.name}
            onChange={(checked) => {
              const plans = checked
                ? selectedPlans.concat(plan.id)
                : selectedPlans.filter((id) => id !== plan.id);
              setSelectedPlans(plans);
            }}
            checked={selectedPlans.includes(plan.id)}
          />
        ))}
      </Stack>
    </>
  );
}

// 'Create' mode should create a new selling plan, and add the current product to it
function Create() {
  const data = useData();
  const {close, done, setPrimaryAction, setSecondaryAction} = useContainer();
  const {getSessionToken} = useSessionToken();

  // Mock plan settings
  const [planTitle, setPlanTitle] = useState('');
  const [percentageOff, setPercentageOff] = useState('');
  const [deliveryFrequency, setDeliveryFrequency] = useState('');

  useEffect(() => {
    setPrimaryAction({
      content: 'Create plan',
      onAction: async () => {
        // Get a fresh session token before every call to your app server.
        const token = await getSessionToken();

        // Here, send the form data to your app server to create the new plan.

        // Upon completion, call done() to trigger a reload of the resource page, and close() to
        // terminate the extension.
        done();
        close();
      },
    });

    setSecondaryAction({
      content: 'Cancel',
      onAction: () => close(),
    });
  }, [getSessionToken]);

  return (
    <Stack vertical>
      <Text>
        Create subscription plan for {`{Product id ${data.productId}}`}
      </Text>

      <TextField
        label="Plan title"
        value={planTitle}
        onAfterChange={setPlanTitle}
      />

      <Stack>
        <TextField
          type="number"
          label="Delivery frequency (in weeks)"
          value={deliveryFrequency}
          onAfterChange={setDeliveryFrequency}
        />
        <TextField
          type="number"
          label="Percentage off (%)"
          value={percentageOff}
          onAfterChange={setPercentageOff}
        />
      </Stack>
    </Stack>
  );
}

// 'Remove' mode should remove the current product from a selling plan.
// This should not delete the selling plan.
function Remove() {
  const data = useData();
  const {close, done, setPrimaryAction, setSecondaryAction} = useContainer();

  useEffect(() => {
    setPrimaryAction({
      content: 'Remove from plan',
      onAction: async () => {
        // Get a fresh session token before every call to your app server.
        const token = await getSessionToken();

        // Here, send the form data to your app server to remove the product from the plan.

        // Upon completion, call done() to trigger a reload of the resource page, and close() to
        // terminate the extension.
        done();
        close();
      },
    });

    setSecondaryAction({
      content: 'Cancel',
      onAction: () => close(),
    });
  }, [getSessionToken]);

  return (
    <Text>
      Remove {`{Product id ${data.productId}}`} from{' '}
      {`{Plan group id ${data.sellingPlanGroupId}}`}
    </Text>
  );
}

// 'Edit' mode should modify an existing selling plan.
// Changes should affect other products that have this plan applied.
function Edit() {
  const data = useData();
  const {close, done, setPrimaryAction, setSecondaryAction} = useContainer();
  const {getSessionToken} = useSessionToken();

  const [planTitle, setPlanTitle] = useState('Current plan');
  const [percentageOff, setPercentageOff] = useState('10');
  const [deliveryFrequency, setDeliveryFrequency] = useState('1');

  useEffect(() => {
    setPrimaryAction({
      content: 'Edit plan',
      onAction: async () => {
        // Get a fresh session token before every call to your app server.
        const token = await getSessionToken();

        // Here, send the form data to your app server to modify the selling plan.

        // Upon completion, call done() to trigger a reload of the resource page, and close() to
        // terminate the extension.
        done();
        close();
      },
    });

    setSecondaryAction({
      content: 'Cancel',
      onAction: () => close(),
    });
  }, [getSessionToken]);

  return (
    <Stack vertical>
      <Text>
        Create subscription plan for {`{Product id ${data.productId}}`}
      </Text>

      <TextField
        label="Plan title"
        value={planTitle}
        onAfterChange={setPlanTitle}
      />

      <Stack>
        <TextField
          type="number"
          label="Delivery frequency (in weeks)"
          value={deliveryFrequency}
          onAfterChange={setDeliveryFrequency}
        />
        <TextField
          type="number"
          label="Percentage off (%)"
          value={percentageOff}
          onAfterChange={setPercentageOff}
        />
      </Stack>
    </Stack>
  );
}

// Your extension must render all four modes
render(ExtensionPoint.SubscriptionManagementAdd, () => <Add />);
render(ExtensionPoint.SubscriptionManagementCreate, () => <Create />);
render(ExtensionPoint.SubscriptionManagementRemove, () => <Remove />);
render(ExtensionPoint.SubscriptionManagementEdit, () => <Edit />);
